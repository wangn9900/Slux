name: Build Android

on:
  push:
    branches: [ main ]
    paths:
      - 'lib/**'
      - 'android/**'
      - 'pubspec.yaml'
      - '.github/workflows/build-android.yml'
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build-android:
    name: Build Android APK
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'
      
      - name: Setup Android NDK
        uses: nttld/setup-ndk@v1
        with:
          ndk-version: r26c
          add-to-path: true
      
      - name: Create Go wrapper directory
        run: mkdir -p core/mobile
      
      - name: Create Go wrapper (main.go)
        run: |
          cat > core/mobile/main.go << 'EOF'
          package main

          import "C"
          import (
              "context"
              "encoding/json"
              
              box "github.com/sagernet/sing-box"
              "github.com/sagernet/sing-box/option"
          )

          var instance *box.Box
          var ctx context.Context
          var cancel context.CancelFunc

          //export start
          func start(configContent *C.char, tunFd C.int) *C.char {
              configJson := C.GoString(configContent)
              
              // 1. Unmarshal to generic map to manipulate JSON fields directly
              // This avoids direct struct field dependency which causes build errors if API changes
              var rawConfig map[string]interface{}
              if err := json.Unmarshal([]byte(configJson), &rawConfig); err != nil {
                  return C.CString("JSON Map Parse Error: " + err.Error())
              }

              // 2. Inject TUN File Descriptor
              if tunFd > 0 {
                  if inbounds, ok := rawConfig["inbounds"].([]interface{}); ok {
                      for i, ib := range inbounds {
                          if inbound, ok := ib.(map[string]interface{}); ok {
                              if t, ok := inbound["type"].(string); ok && t == "tun" {
                                  // Inject fields recognized by sing-box JSON decoder
                                  inbound["file_descriptor"] = int(tunFd)
                                  inbound["auto_route"] = false
                                  inbound["interface_name"] = ""
                                  // Save changes
                                  inbounds[i] = inbound
                              }
                          }
                      }
                      // Save updated inbounds list
                      rawConfig["inbounds"] = inbounds
                  }
              }

              // 3. Marshal back to bytes
              newBytes, err := json.Marshal(rawConfig)
              if err != nil {
                  return C.CString("JSON Remarshal Error: " + err.Error())
              }

              // 4. Unmarshal to Typed Options
              var options option.Options
              if err := json.Unmarshal(newBytes, &options); err != nil {
                  return C.CString("Final Config Parse Error: " + err.Error())
              }

              ctx, cancel = context.WithCancel(context.Background())
              var genErr error
              instance, genErr = box.New(box.Options{
                  Context: ctx,
                  Options: options,
              })
              if genErr != nil {
                 return C.CString("Create Box Error: " + genErr.Error())
              }
              if err != nil {
                  return C.CString("Create Box Error: " + err.Error())
              }

              if err := instance.Start(); err != nil {
                  return C.CString("Start Error: " + err.Error())
              }

              return nil
          }

          //export stop
          func stop() {
              if cancel != nil {
                  cancel()
              }
              if instance != nil {
                  instance.Close()
                  instance = nil
              }
          }

          func main() {}
          EOF
      
      - name: Initialize Go module
        working-directory: core/mobile
        run: |
          if [ ! -f go.mod ]; then
            go mod init libbox
          fi
          go get github.com/sagernet/sing-box@latest
          go mod tidy
      
      - name: Build libbox.so for arm64-v8a
        working-directory: core/mobile
        run: |
          export CC=$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android29-clang
          export CXX=$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android29-clang++
          CGO_ENABLED=1 GOOS=android GOARCH=arm64 \
          go build -buildmode=c-shared -trimpath -ldflags="-s -w" -o libbox.so main.go
      
      - name: Build libbox.so for armeabi-v7a
        working-directory: core/mobile
        run: |
          export CC=$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/armv7a-linux-androideabi29-clang
          export CXX=$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/armv7a-linux-androideabi29-clang++
          CGO_ENABLED=1 GOOS=android GOARCH=arm GOARM=7 \
          go build -buildmode=c-shared -trimpath -ldflags="-s -w" -o libbox-armeabi-v7a.so main.go
      
      - name: Build libbox.so for x86_64
        working-directory: core/mobile
        run: |
          export CC=$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/x86_64-linux-android29-clang
          export CXX=$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/x86_64-linux-android29-clang++
          CGO_ENABLED=1 GOOS=android GOARCH=amd64 \
          go build -buildmode=c-shared -trimpath -ldflags="-s -w" -o libbox-x86_64.so main.go
      
      - name: Copy to jniLibs
        run: |
          mkdir -p android/app/src/main/jniLibs/arm64-v8a
          mkdir -p android/app/src/main/jniLibs/armeabi-v7a
          mkdir -p android/app/src/main/jniLibs/x86_64
          cp core/mobile/libbox.so android/app/src/main/jniLibs/arm64-v8a/
          cp core/mobile/libbox-armeabi-v7a.so android/app/src/main/jniLibs/armeabi-v7a/libbox.so
          cp core/mobile/libbox-x86_64.so android/app/src/main/jniLibs/x86_64/libbox.so
      
      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: 'zulu'
          java-version: '17'
      
      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: '3.24.5'
          channel: 'stable'
      
      - name: Get Flutter dependencies
        run: flutter pub get
      
      - name: Generate app icons
        run: |
          sudo apt-get update
          sudo apt-get install -y imagemagick
          
          # Generate Android icons
          ANDROID_PATH="android/app/src/main/res"
          mkdir -p "$ANDROID_PATH/mipmap-mdpi"
          mkdir -p "$ANDROID_PATH/mipmap-hdpi"
          mkdir -p "$ANDROID_PATH/mipmap-xhdpi"
          mkdir -p "$ANDROID_PATH/mipmap-xxhdpi"
          mkdir -p "$ANDROID_PATH/mipmap-xxxhdpi"
          
          # Use the pre-generated asset icon
          SOURCE_ICON="assets/app_icon.png"
          
          convert "$SOURCE_ICON" -resize 48x48 "$ANDROID_PATH/mipmap-mdpi/ic_launcher.png"
          convert "$SOURCE_ICON" -resize 72x72 "$ANDROID_PATH/mipmap-hdpi/ic_launcher.png"
          convert "$SOURCE_ICON" -resize 96x96 "$ANDROID_PATH/mipmap-xhdpi/ic_launcher.png"
          convert "$SOURCE_ICON" -resize 144x144 "$ANDROID_PATH/mipmap-xxhdpi/ic_launcher.png"
          convert "$SOURCE_ICON" -resize 192x192 "$ANDROID_PATH/mipmap-xxxhdpi/ic_launcher.png"
      
      - name: Build Android APK
        run: flutter build apk --release
      
      - name: Upload APK
        uses: actions/upload-artifact@v4
        with:
          name: slux-android-apk
          path: build/app/outputs/flutter-apk/app-release.apk
      
      - name: Upload libbox.so artifacts
        uses: actions/upload-artifact@v4
        with:
          name: libbox-libraries
          path: |
            android/app/src/main/jniLibs/arm64-v8a/libbox.so
            android/app/src/main/jniLibs/armeabi-v7a/libbox.so
            android/app/src/main/jniLibs/x86_64/libbox.so
